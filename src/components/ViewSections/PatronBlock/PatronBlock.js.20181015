import _ from 'lodash';
import React from 'react';
import PropTypes from 'prop-types';
import {
  Row,
  Col,
  Accordion,
  MultiColumnList,
  Button,
  Headline
} from '@folio/stripes/components';
import moment from 'moment';

class PatronBlock extends React.Component {
  static manifest = Object.freeze({
    userPatronBlocks: {
      type: 'okapi',
      records: 'manualblocks',
      path: 'manualblocks?query=userId=:{id}',
    },
  });

  static propTypes = {
    resources: PropTypes.shape({
      manualblocks: PropTypes.shape({
        records: PropTypes.arrayOf(PropTypes.object),
      }),
    }),
    accordionId: PropTypes.string,
    addRecord: PropTypes.bool,
    expanded: PropTypes.bool,
    onToggle: PropTypes.func,
    onClickViewPatronBlock: PropTypes.func,
  };

  constructor(props) {
    super(props);

    this.onSort = this.onSort.bind(this);
    this.onRowClick = this.onRowClick.bind(this);

    this.sortMap = {
      'Type': f => f.type,
      'Display description': f => f.desc,
      'Blocked actions': f => f.renewals,
    };

    this.state = {
      sortOrder: [
       'Type',
       'Display description',
       'Blocked actions',
      ],
      sortDirection: ['desc', 'asc'],
    };
  }

  componentDidUpdate(prevProps) {
    const prevBlocks = _.get(prevProps.resources, ['userPatronBlocks', 'records'], []);
    const patronBlocks = _.get(this.props.resources, ['userPatronBlocks', 'records'], []);

    if (JSON.stringify(prevBlocks) !== JSON.stringify(patronBlocks)) {
      const expirated = patronBlocks.filter(p => moment(moment(p.expirationDate).format()).isBefore(moment().format())) || [];
      console.log(expirated);
    }
  }

  onSort(e, meta) {
    if (!this.sortMap[meta.alias]) return;

    let { sortOrder, sortDirection } = this.state;

    if (sortOrder[0] !== meta.alias) {
      sortOrder = [meta.alias, sortOrder[1]];
      sortDirection = ['asc', sortDirection[1]];
    } else {
      const direction = (sortDirection[0] === 'desc') ? 'asc' : 'desc';
      sortDirection = [direction, sortDirection[1]];
    }
      this.setState({ ...this.state, sortOrder, sortDirection });
  }

  onRowClick(e, row) {
    if ((e.target.type !== 'button') && (e.target.tagName !== 'IMG')) {
      this.props.onClickViewPatronBlock(e, 'edit', row);
    }
  }

  getPatronFormatter(){
    return{
      'Type': f => f.type, 
      'Display description': f => f.desc, 
      'Blocked actions': f =>`${ f.renewals ? 'renewals ' : ''}${f.requests ? 'requests ' : ''}${f.borrowing ? 'borrowing ' : ''}`, 
    }  
  }  

  render() {
    const props = this.props; 
    const { expanded, onToggle, accordionId } = props;
    const { sortOrder, sortDirection } = this.state;
    const visibleColumns = ['Type', 'Display description', 'Blocked actions'];
    const manualBlocks = _.get(this.props.resources, ['userPatronBlocks', 'records'], []);
    const contentData = _.orderBy(manualBlocks, [this.sortMap[sortOrder[0]], this.sortMap[sortOrder[1]]], sortDirection);
    const displayWhenOpen = 
      <Button onClick={e => { props.onClickViewPatronBlock(e, 'add') }} >+Add Block</Button>;

    const items = (manualBlocks.length === 0) ? '':
      <MultiColumnList
        contentData={contentData}
        formatter={this.getPatronFormatter()}
        visibleColumns={visibleColumns}
        onHeaderClick={this.onSort}
        sortOrder={sortOrder[0]}
        sortDirection={`${sortDirection[0]}ending`}
        onRowClick={this.onRowClick}
      />;

    return(
      <Accordion
        open={expanded}
        id={accordionId}
        onToggle={onToggle}
        label={<Headline size="large" tag="h3">Patron Block</Headline>}
        displayWhenOpen={displayWhenOpen}
      >
        {items}
      </Accordion>
    );  
  }  
}

export default PatronBlock;
